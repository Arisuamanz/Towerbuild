<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hutan Magis: Serangan Otomatis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DeviceOrientationControls.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #0a1520; font-family: sans-serif; touch-action: none; user-select: none; }
        #canvas-3d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #canvas-2d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 25; pointer-events: none; }
        
        .cinematic-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
            background-image: url('https://upload.wikimedia.org/wikipedia/commons/7/76/1k_Grain.png');
            opacity: 0.15; pointer-events: none; z-index: 20; mix-blend-mode: overlay;
        }

        #gameUI { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; display: none; }
        #scoreDisplay { position: absolute; top: 20px; right: 20px; color: #fcd34d; font-size: 1.5rem; font-weight: bold; text-shadow: 0 0 10px rgba(252,211,77,0.5); }
        #hpContainer { position: absolute; top: 20px; left: 20px; width: 200px; height: 12px; background: rgba(0,0,0,0.5); border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #hpBar { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #44ff44); transition: width 0.3s; }
        
        #crosshair { 
            position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; 
            transform: translate(-50%, -50%); box-shadow: 0 0 8px #fff;
            transition: transform 0.1s;
        }
        #crosshair.locked { border-color: #fcd34d; transform: translate(-50%, -50%) scale(1.3); }
        
        #gyroStatus {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 0.8rem; z-index: 110; background: rgba(0,0,0,0.6);
            padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
        }

        /* Butang Center */
        .btn-center-cam {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.4);
            color: white; padding: 10px 30px; border-radius: 30px; font-size: 1rem;
            backdrop-filter: blur(5px); pointer-events: auto; cursor: pointer; transition: 0.2s;
            z-index: 120;
        }
        .btn-center-cam:active { background: rgba(255, 255, 255, 0.4); transform: translateX(-50%) scale(0.95); }

        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 21, 32, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center;
        }
        .btn-enter {
            padding: 15px 45px; border: 2px solid #fcd34d; background: transparent; color: #fcd34d;
            font-size: 1.2rem; cursor: pointer; border-radius: 40px; text-transform: uppercase; pointer-events: auto;
        }
        .btn-enter:hover { background: #fcd34d; color: #000; box-shadow: 0 0 20px #fcd34d; }
        #damageFlash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: red; opacity: 0; pointer-events: none; z-index: 150; }
    </style>
</head>
<body>

    <div id="mainMenu" class="menu-overlay">
        <h1 class="text-4xl text-amber-100 mb-2 font-light tracking-widest">HUTAN MAGIS</h1>
        <p class="text-gray-400 italic mb-8">Dunia 360Â° â€¢ Auto Attack â€¢ Burung & Hantu</p>
        <button class="btn-enter" onclick="requestAccess()">Mula Bermain</button>
    </div>

    <div id="gameOverMenu" class="menu-overlay" style="display:none;">
        <h1 class="text-5xl text-red-600 mb-4 font-bold">GAME OVER</h1>
        <p id="finalScore" class="text-2xl text-amber-300 mb-8">Skor Akhir: 0</p>
        <button class="btn-enter" onclick="location.reload()">Main Lagi</button>
    </div>

    <div id="gameUI">
        <div id="hpContainer"><div id="hpBar"></div></div>
        <div id="scoreDisplay">Skor: 0</div>
        <div id="gyroStatus">Mencari Sensor Gerak...</div>
        <div id="crosshair"></div>
        <button class="btn-center-cam" onclick="centerCamera()">ðŸŽ¯ Depan</button>
        <div id="damageFlash"></div>
    </div>

    <div class="cinematic-overlay"></div>
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d"></div>

    <script>
        // --- DATA PERMAINAN ---
        let isPlaying = false, score = 0, hp = 100;
        let enemies = [], enemySpawnInterval;
        let hasCenteredInitially = false; 
        const clock = new THREE.Clock();

        // --- SISTEM ROTASI ---
        let rotationY = 0, rotationX = 0;
        const LIMIT_X = 0.6; 
        let gyroActive = false;
        let controls; 

        function requestAccess() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(state => {
                    startGame();
                }).catch(() => startGame());
            } else {
                startGame();
            }
        }

        window.addEventListener('deviceorientation', (e) => {
            if (e.alpha !== null && isPlaying && !gyroActive) {
                gyroActive = true;
                document.getElementById('gyroStatus').innerText = "Gyro: Aktif (360Â°)";
                controls = new THREE.DeviceOrientationControls(camera);
            }
        });

        // --- FUNGSI RESET KAMERA KE DEPAN ---
        function centerCamera() {
            if (gyroActive && controls) {
                controls.alphaOffset = 0;
                controls.update();
                
                let euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                controls.alphaOffset = -euler.y;
                controls.update();
            } else {
                rotationY = 0;
                rotationX = 0;
            }
        }

        // --- SISTEM AUDIO ---
        let audioCtx, gainNode;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.5;
            gainNode.connect(audioCtx.destination);

            const bufferSize = 2 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

            const rainSource = audioCtx.createBufferSource();
            rainSource.buffer = noiseBuffer;
            rainSource.loop = true;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 700;

            rainSource.connect(filter);
            filter.connect(gainNode);
            rainSource.start();
        }

        function playChime() {
            if (!audioCtx) return;
            const freq = [523.25, 659.25, 783.99, 880.00][Math.floor(Math.random()*4)];
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.value = freq;
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.05);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
            osc.connect(g); g.connect(gainNode);
            osc.start(); osc.stop(audioCtx.currentTime + 1.2);
        }

        function playThunder() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(45, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 3);
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3);
            osc.connect(g); g.connect(gainNode);
            osc.start(); osc.stop(audioCtx.currentTime + 3);
        }

        // --- SISTEM 2D SPARKLE ---
        const canvas2D = document.getElementById('canvas-2d');
        const ctx2D = canvas2D.getContext('2d');
        let w2D = window.innerWidth, h2D = window.innerHeight;
        canvas2D.width = w2D; canvas2D.height = h2D;
        const sparkles = [];

        class Sparkle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = Math.random() * 5 + 2;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 12 + 5;
                this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
                this.life = 1.0; this.decay = Math.random() * 0.02 + 0.02;
            }
            update(ts) {
                this.x += this.vx * ts; this.y += this.vy * ts;
                this.vx *= Math.pow(0.85, ts); this.vy *= Math.pow(0.85, ts);
                this.vy -= 0.1 * ts; this.life -= this.decay * ts;
            }
            draw() {
                ctx2D.globalCompositeOperation = 'lighter';
                ctx2D.beginPath(); ctx2D.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx2D.fillStyle = `hsla(45, 100%, 75%, ${this.life})`;
                ctx2D.shadowBlur = 15; ctx2D.shadowColor = "orange"; ctx2D.fill();
            }
        }

        // --- SISTEM 3D ---
        let scene, camera, renderer, raycaster, rainGeo;
        
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1520);
            scene.fog = new THREE.FogExp2(0x0a1520, 0.025);

            camera = new THREE.PerspectiveCamera(60, w2D / h2D, 0.1, 1000);
            camera.position.set(0, 1.8, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(w2D, h2D);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-3d').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            scene.add(new THREE.AmbientLight(0x2a3b4c, 1.2));

            scene.add(new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshLambertMaterial({ color: 0x0a150f })).rotateX(-Math.PI/2));
            
            for (let i = 0; i < 200; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 4), new THREE.MeshLambertMaterial({ color: 0x2a1605 }));
                trunk.position.y = 2; tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 5), new THREE.MeshLambertMaterial({ color: 0x0f2515 }));
                leaves.position.y = 4.5; tree.add(leaves);
                const d = 25 + Math.random() * 75, a = Math.random() * Math.PI * 2;
                tree.position.set(Math.cos(a)*d, 0, Math.sin(a)*d);
                scene.add(tree);
            }

            const rCount = 2000;
            rainGeo = new THREE.BufferGeometry();
            const rPos = new Float32Array(rCount * 3);
            for(let i=0; i<rCount*3; i+=3) {
                rPos[i] = (Math.random()-0.5)*100; rPos[i+1] = Math.random()*40; rPos[i+2] = (Math.random()-0.5)*100;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(rPos, 3));
            scene.add(new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0x88aabb, size: 0.1, transparent: true, opacity: 0.6 })));

            let isDown = false, lastX = 0, lastY = 0;
            const startP = (e) => { isDown = true; const p = e.touches ? e.touches[0] : e; lastX = p.clientX; lastY = p.clientY; };
            const moveP = (e) => {
                if(!isDown || gyroActive) return;
                const p = e.touches ? e.touches[0] : e;
                rotationY -= (p.clientX - lastX) * 0.005;
                rotationX -= (p.clientY - lastY) * 0.005;
                rotationX = Math.max(-LIMIT_X, Math.min(LIMIT_X, rotationX));
                lastX = p.clientX; lastY = p.clientY;
            };
            const endP = () => { isDown = false; };

            window.addEventListener('mousedown', startP); window.addEventListener('mousemove', moveP); window.addEventListener('mouseup', endP);
            window.addEventListener('touchstart', startP); window.addEventListener('touchmove', moveP); window.addEventListener('touchend', endP);
        }

        // --- SISTEM MUSUH (HANTU & BURUNG) ---
        function spawnEnemy() {
            if(!isPlaying) return;
            const ang = (Math.random() - 0.5) * (Math.PI * (120/180)); 
            const dist = 45;
            const enemy = new THREE.Group();
            
            let hitMesh;
            const isBird = Math.random() > 0.5;

            if (isBird) {
                // --- BURUNG HITAM ---
                const birdMat = new THREE.MeshBasicMaterial({ color: 0x050505 }); 
                const bodyGeo = new THREE.ConeGeometry(0.5, 2, 4);
                bodyGeo.rotateX(Math.PI / 2);
                const body = new THREE.Mesh(bodyGeo, birdMat);
                
                const wingGeo = new THREE.ConeGeometry(2.5, 1, 3);
                const wings = new THREE.Mesh(wingGeo, birdMat);
                
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.12), eyeMat);
                eye1.position.set(0.2, 0.2, 0.5);
                const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.12), eyeMat);
                eye2.position.set(-0.2, 0.2, 0.5);

                enemy.add(body); enemy.add(wings); enemy.add(eye1); enemy.add(eye2);

                hitMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({ visible: false }));
                enemy.add(hitMesh);

                enemy.position.set(Math.sin(ang)*dist, 12 + Math.random() * 8, -Math.cos(ang)*dist);
                enemy.lookAt(camera.position);
                enemy.userData = { type: 'bird', wings: wings, wingAngle: 0 };
                
            } else {
                // --- HANTU PUTIH (REKA BENTUK BARU) ---
                const ghostMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
                
                // Kepala Hantu (Bulat)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), ghostMat);
                head.position.y = 0.8;

                // Badan Hantu (Kain Meleret/Kon Terbalik)
                const bodyGeo = new THREE.ConeGeometry(0.7, 2.5, 16);
                bodyGeo.rotateX(Math.PI); // Pusing supaya muncung tajam di bawah
                const body = new THREE.Mesh(bodyGeo, ghostMat);
                body.position.y = -0.4;

                // Mata Hitam
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.1), eyeMat);
                eye1.position.set(0.25, 0.8, 0.55); // Posisi mata Z menghala ke depan
                const eye2 = new THREE.Mesh(new THREE.SphereGeometry(0.1), eyeMat);
                eye2.position.set(-0.25, 0.8, 0.55);

                // Cahaya dari Hantu (Glow Putih)
                const glow = new THREE.PointLight(0xffffff, 1.5, 15);
                glow.position.y = 0.5;

                enemy.add(head);
                enemy.add(body);
                enemy.add(eye1);
                enemy.add(eye2);
                enemy.add(glow);

                hitMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({ visible: false }));
                enemy.add(hitMesh);

                enemy.position.set(Math.sin(ang)*dist, 1.5, -Math.cos(ang)*dist);
                
                // Set offset apungan secara rawak supaya setiap hantu bergerak berbeza
                enemy.userData = { type: 'ghost', floatOffset: Math.random() * Math.PI * 2 };
            }

            scene.add(enemy);
            enemies.push({ mesh: enemy, hit: hitMesh });
        }

        // --- SISTEM SERANGAN (AUTO ATTACK) ---
        function autoAttack() {
            if(!isPlaying) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const targets = enemies.map(e => e.hit);
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                const idx = enemies.findIndex(e => e.hit === target);
                document.getElementById('crosshair').classList.add('locked');

                if (idx > -1) {
                    playChime();
                    for(let i=0; i<15; i++) sparkles.push(new Sparkle(w2D/2, h2D/2));
                    scene.remove(enemies[idx].mesh);
                    enemies.splice(idx, 1);
                    score += 10; document.getElementById('scoreDisplay').innerText = `Skor: ${score}`;
                }
            } else {
                document.getElementById('crosshair').classList.remove('locked');
            }
        }

        function takeDamage() {
            hp -= 20; document.getElementById('hpBar').style.width = hp + "%";
            const f = document.getElementById('damageFlash'); f.style.opacity = 0.5; setTimeout(() => f.style.opacity = 0, 100);
            if(hp <= 0) {
                isPlaying = false; clearInterval(enemySpawnInterval);
                document.getElementById('gameUI').style.display = "none";
                document.getElementById('gameOverMenu').style.display = "flex";
                document.getElementById('finalScore').innerText = `Skor Akhir: ${score}`;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            let dt = clock.getDelta(); if(dt > 0.1) dt = 0.1;
            let ts = dt * 60;

            if(isPlaying) {
                if (gyroActive && controls) {
                    controls.update();
                    if (!hasCenteredInitially) {
                        centerCamera();
                        hasCenteredInitially = true;
                    }
                } else {
                    camera.rotation.set(rotationX, rotationY, 0);
                }

                autoAttack();

                for(let i = enemies.length-1; i >= 0; i--) {
                    const e = enemies[i];
                    const dir = new THREE.Vector3().subVectors(camera.position, e.mesh.position).normalize();
                    
                    if (e.mesh.userData.type === 'bird') {
                        // Pergerakan Burung
                        e.mesh.position.add(dir.multiplyScalar(0.13 * ts));
                        e.mesh.lookAt(camera.position); 
                        e.mesh.userData.wingAngle += 0.4 * ts;
                        e.mesh.userData.wings.scale.x = 0.3 + 0.7 * Math.abs(Math.cos(e.mesh.userData.wingAngle));
                    } else {
                        // Pergerakan Hantu Putih
                        e.mesh.position.add(dir.multiplyScalar(0.09 * ts));
                        
                        // Hantu memandang pemain supaya muka nampak sentiasa
                        e.mesh.lookAt(camera.position);
                        
                        // Efek hantu terapung-apung (bobbing up and down)
                        e.mesh.position.y += Math.sin(Date.now() * 0.003 + e.mesh.userData.floatOffset) * 0.02 * ts;
                    }

                    if(e.mesh.position.distanceTo(camera.position) < 2.5) {
                        scene.remove(e.mesh); enemies.splice(i, 1); takeDamage();
                    }
                }

                const rPos = rainGeo.attributes.position.array;
                for(let i=1; i<rPos.length; i+=3) {
                    rPos[i] -= 0.6 * ts; if(rPos[i] < 0) rPos[i] = 40;
                }
                rainGeo.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);

            ctx2D.clearRect(0,0, w2D, h2D);
            for(let i = sparkles.length-1; i >= 0; i--) {
                const s = sparkles[i]; s.update(ts);
                if(s.life <= 0) sparkles.splice(i, 1); else s.draw();
            }
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = "none";
            document.getElementById('gameUI').style.display = "block";
            hasCenteredInitially = false; 
            initAudio();
            if(!scene) init3D();
            score = 0; hp = 100; isPlaying = true;
            clock.start(); animate();
            enemySpawnInterval = setInterval(spawnEnemy, 1600);
        }

        window.addEventListener('resize', () => {
            w2D = window.innerWidth; h2D = window.innerHeight;
            canvas2D.width = w2D; canvas2D.height = h2D;
            camera.aspect = w2D / h2D; camera.updateProjectionMatrix();
            renderer.setSize(w2D, h2D);
        });
    </script>
</body>
</html>


