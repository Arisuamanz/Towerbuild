<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hutan Magis: Kutip Bintang & Rama-Rama</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DeviceOrientationControls.js"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #0a1520; font-family: sans-serif; touch-action: none; user-select: none; }
        #canvas-3d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #canvas-2d { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 25; pointer-events: none; }
        
        .cinematic-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
            background-image: url('https://upload.wikimedia.org/wikipedia/commons/7/76/1k_Grain.png');
            opacity: 0.15; pointer-events: none; z-index: 20; mix-blend-mode: overlay;
        }

        #gameUI { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; display: none; }
        #scoreDisplay { position: absolute; top: 20px; right: 20px; color: #fcd34d; font-size: 1.5rem; font-weight: bold; text-shadow: 0 0 10px rgba(252,211,77,0.5); }
        #hpContainer { position: absolute; top: 20px; left: 20px; width: 200px; height: 12px; background: rgba(0,0,0,0.5); border: 2px solid #fff; border-radius: 10px; overflow: hidden; }
        #hpBar { width: 100%; height: 100%; background: linear-gradient(90deg, #ffcc00, #00ffcc); transition: width 0.3s; }
        
        #crosshair { 
            position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; 
            transform: translate(-50%, -50%); box-shadow: 0 0 8px #fff;
            transition: transform 0.1s;
        }
        #crosshair.locked { border-color: #fcd34d; transform: translate(-50%, -50%) scale(1.3); }
        
        #gyroStatus {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 0.8rem; z-index: 110; background: rgba(0,0,0,0.6);
            padding: 5px 15px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
        }

        /* Butang Center */
        .btn-center-cam {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.4);
            color: white; padding: 10px 30px; border-radius: 30px; font-size: 1rem;
            backdrop-filter: blur(5px); pointer-events: auto; cursor: pointer; transition: 0.2s;
            z-index: 120;
        }
        .btn-center-cam:active { background: rgba(255, 255, 255, 0.4); transform: translateX(-50%) scale(0.95); }

        .menu-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 21, 32, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 200; text-align: center;
        }
        .btn-enter {
            padding: 15px 45px; border: 2px solid #fcd34d; background: transparent; color: #fcd34d;
            font-size: 1.2rem; cursor: pointer; border-radius: 40px; text-transform: uppercase; pointer-events: auto;
        }
        .btn-enter:hover { background: #fcd34d; color: #000; box-shadow: 0 0 20px #fcd34d; }
        #damageFlash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #ffd700; opacity: 0; pointer-events: none; z-index: 150; }
    </style>
</head>
<body>

    <div id="mainMenu" class="menu-overlay">
        <h1 class="text-4xl text-amber-100 mb-2 font-light tracking-widest">HUTAN MAGIS</h1>
        <p class="text-gray-400 italic mb-8">Dunia 360Â° â€¢ Bintang & Rama-Rama (90Â°)</p>
        <button class="btn-enter" onclick="requestAccess()">Mula Santai</button>
    </div>

    <div id="gameOverMenu" class="menu-overlay" style="display:none;">
        <h1 class="text-5xl text-amber-500 mb-4 font-bold">REHAT SEBENTAR</h1>
        <p id="finalScore" class="text-2xl text-amber-300 mb-8">Skor Cozy: 0</p>
        <button class="btn-enter" onclick="location.reload()">Main Lagi</button>
    </div>

    <div id="gameUI">
        <div id="hpContainer"><div id="hpBar"></div></div>
        <div id="scoreDisplay">Cozy: 0</div>
        <div id="gyroStatus">Mencari Sensor Gerak...</div>
        <div id="crosshair"></div>
        <button class="btn-center-cam" onclick="centerCamera()">ðŸŽ¯ Depan</button>
        <div id="damageFlash"></div>
    </div>

    <div class="cinematic-overlay"></div>
    <canvas id="canvas-2d"></canvas>
    <div id="canvas-3d"></div>

    <script>
        // --- DATA PERMAINAN ---
        let isPlaying = false, score = 0, hp = 100;
        let enemies = [], enemySpawnInterval;
        let hasCenteredInitially = false; 
        const clock = new THREE.Clock();

        // --- SISTEM ROTASI ---
        let rotationY = 0, rotationX = 0;
        const LIMIT_X = 0.6; 
        let gyroActive = false;
        let controls; 

        function requestAccess() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(state => {
                    startGame();
                }).catch(() => startGame());
            } else {
                startGame();
            }
        }

        window.addEventListener('deviceorientation', (e) => {
            if (e.alpha !== null && isPlaying && !gyroActive) {
                gyroActive = true;
                document.getElementById('gyroStatus').innerText = "Gyro: Aktif (360Â°)";
                controls = new THREE.DeviceOrientationControls(camera);
            }
        });

        function centerCamera() {
            if (gyroActive && controls) {
                controls.alphaOffset = 0;
                controls.update();
                let euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                controls.alphaOffset = -euler.y;
                controls.update();
            } else {
                rotationY = 0;
                rotationX = 0;
            }
        }

        // --- SISTEM AUDIO ---
        let audioCtx, gainNode;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.5;
            gainNode.connect(audioCtx.destination);

            const bufferSize = 2 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;

            const rainSource = audioCtx.createBufferSource();
            rainSource.buffer = noiseBuffer;
            rainSource.loop = true;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 700;

            rainSource.connect(filter);
            filter.connect(gainNode);
            rainSource.start();
        }

        function playChime() {
            if (!audioCtx) return;
            const freq = [523.25, 659.25, 783.99, 880.00][Math.floor(Math.random()*4)];
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.value = freq;
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.05);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
            osc.connect(g); g.connect(gainNode);
            osc.start(); osc.stop(audioCtx.currentTime + 1.2);
        }

        function playThunder() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(45, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 3);
            g.gain.setValueAtTime(0, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3);
            osc.connect(g); g.connect(gainNode);
            osc.start(); osc.stop(audioCtx.currentTime + 3);
        }

        // --- SISTEM 2D SPARKLE ---
        const canvas2D = document.getElementById('canvas-2d');
        const ctx2D = canvas2D.getContext('2d');
        let w2D = window.innerWidth, h2D = window.innerHeight;
        canvas2D.width = w2D; canvas2D.height = h2D;
        const sparkles = [];

        class Sparkle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = Math.random() * 5 + 2;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 12 + 5;
                this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
                this.life = 1.0; this.decay = Math.random() * 0.02 + 0.02;
            }
            update(ts) {
                this.x += this.vx * ts; this.y += this.vy * ts;
                this.vx *= Math.pow(0.85, ts); this.vy *= Math.pow(0.85, ts);
                this.vy -= 0.1 * ts; this.life -= this.decay * ts;
            }
            draw() {
                ctx2D.globalCompositeOperation = 'lighter';
                ctx2D.beginPath(); ctx2D.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx2D.fillStyle = `hsla(45, 100%, 75%, ${this.life})`;
                ctx2D.shadowBlur = 15; ctx2D.shadowColor = "orange"; ctx2D.fill();
            }
        }

        // --- SISTEM 3D ---
        let scene, camera, renderer, raycaster, rainGeo;
        
        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1520);
            scene.fog = new THREE.FogExp2(0x0a1520, 0.025);

            camera = new THREE.PerspectiveCamera(60, w2D / h2D, 0.1, 1000);
            camera.position.set(0, 1.8, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(w2D, h2D);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-3d').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            scene.add(new THREE.AmbientLight(0x2a3b4c, 1.2));

            scene.add(new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshLambertMaterial({ color: 0x0a150f })).rotateX(-Math.PI/2));
            
            for (let i = 0; i < 200; i++) {
                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 4), new THREE.MeshLambertMaterial({ color: 0x2a1605 }));
                trunk.position.y = 2; tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 5), new THREE.MeshLambertMaterial({ color: 0x0f2515 }));
                leaves.position.y = 4.5; tree.add(leaves);
                const d = 25 + Math.random() * 75, a = Math.random() * Math.PI * 2;
                tree.position.set(Math.cos(a)*d, 0, Math.sin(a)*d);
                scene.add(tree);
            }

            const rCount = 2000;
            rainGeo = new THREE.BufferGeometry();
            const rPos = new Float32Array(rCount * 3);
            for(let i=0; i<rCount*3; i+=3) {
                rPos[i] = (Math.random()-0.5)*100; rPos[i+1] = Math.random()*40; rPos[i+2] = (Math.random()-0.5)*100;
            }
            rainGeo.setAttribute('position', new THREE.BufferAttribute(rPos, 3));
            scene.add(new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0x88aabb, size: 0.1, transparent: true, opacity: 0.6 })));

            let isDown = false, lastX = 0, lastY = 0;
            const startP = (e) => { isDown = true; const p = e.touches ? e.touches[0] : e; lastX = p.clientX; lastY = p.clientY; };
            const moveP = (e) => {
                if(!isDown || gyroActive) return;
                const p = e.touches ? e.touches[0] : e;
                rotationY -= (p.clientX - lastX) * 0.005;
                rotationX -= (p.clientY - lastY) * 0.005;
                rotationX = Math.max(-LIMIT_X, Math.min(LIMIT_X, rotationX));
                lastX = p.clientX; lastY = p.clientY;
            };
            const endP = () => { isDown = false; };

            window.addEventListener('mousedown', startP); window.addEventListener('mousemove', moveP); window.addEventListener('mouseup', endP);
            window.addEventListener('touchstart', startP); window.addEventListener('touchmove', moveP); window.addEventListener('touchend', endP);
        }

        // --- SISTEM REKA BENTUK: SHINY STAR & BUTTERFLY (90Â° SPAWN) ---
        function spawnEnemy() {
            if(!isPlaying) return;
            
            // Spawn di hadapan (1/2 PI = 90 darjah)
            const ang = (Math.random() - 0.5) * (Math.PI * (90/180)); 
            const dist = 45;
            const enemy = new THREE.Group();
            
            let hitMesh;
            const isSkyStar = Math.random() > 0.5;

            if (isSkyStar) {
                // --- 1. SHINY STAR (Bintang Bersinar dari Atas) ---
                const starGroup = new THREE.Group();
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const core = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), coreMat);
                starGroup.add(core);

                // Pancaran Cahaya Bintang (Sinar X, Y, Z)
                const rayMat = new THREE.MeshBasicMaterial({ color: 0xffe600, transparent: true, opacity: 0.7 });
                
                const rayY = new THREE.Mesh(new THREE.OctahedronGeometry(0.3, 0), rayMat);
                rayY.scale.set(1, 4, 1);
                starGroup.add(rayY);
                
                const rayX = new THREE.Mesh(new THREE.OctahedronGeometry(0.3, 0), rayMat);
                rayX.scale.set(4, 1, 1);
                starGroup.add(rayX);
                
                const rayZ = new THREE.Mesh(new THREE.OctahedronGeometry(0.3, 0), rayMat);
                rayZ.scale.set(1, 1, 4);
                starGroup.add(rayZ);

                const glow = new THREE.PointLight(0xffe600, 2, 25);
                starGroup.add(glow);

                enemy.add(starGroup);

                // Kotak perlanggaran halimunan
                hitMesh = new THREE.Mesh(new THREE.SphereGeometry(2.0), new THREE.MeshBasicMaterial({ visible: false }));
                enemy.add(hitMesh);

                enemy.position.set(Math.sin(ang)*dist, 15 + Math.random() * 5, -Math.cos(ang)*dist);
                
                // Simpan rujukan kumpulan bintang untuk diputarkan nanti
                enemy.userData = { type: 'skyStar', starMesh: starGroup };
                
            } else {
                // --- 2. RAMA-RAMA COZY (Butterfly) ---
                const butterflyGroup = new THREE.Group();
                
                // Badan Rama-rama
                const bodyMat = new THREE.MeshBasicMaterial({ color: 0xe6ffff });
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8), bodyMat);
                body.rotation.x = Math.PI / 2; // Badan memanjang ke depan
                butterflyGroup.add(body);

                // Sayap Rama-rama
                const wingMat = new THREE.MeshBasicMaterial({ color: 0x00e6ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                const wingGeo = new THREE.PlaneGeometry(1.5, 2);
                wingGeo.rotateX(-Math.PI / 2); // Baringkan sayap

                // Sayap Kanan
                const wingR = new THREE.Mesh(wingGeo, wingMat);
                wingR.position.set(0.75, 0, 0); // Anjakan supaya ia mengepak dari tengah badan
                const wingRPivot = new THREE.Group();
                wingRPivot.add(wingR);
                butterflyGroup.add(wingRPivot);

                // Sayap Kiri
                const wingL = new THREE.Mesh(wingGeo, wingMat);
                wingL.position.set(-0.75, 0, 0);
                const wingLPivot = new THREE.Group();
                wingLPivot.add(wingL);
                butterflyGroup.add(wingLPivot);

                const glow = new THREE.PointLight(0x00e6ff, 1.5, 20);
                butterflyGroup.add(glow);

                enemy.add(butterflyGroup);

                hitMesh = new THREE.Mesh(new THREE.SphereGeometry(2.0), new THREE.MeshBasicMaterial({ visible: false }));
                enemy.add(hitMesh);

                enemy.position.set(Math.sin(ang)*dist, 1.5 + Math.random() * 2, -Math.cos(ang)*dist);
                
                // Simpan rujukan untuk animasi mengepak sayap
                enemy.userData = { 
                    type: 'butterfly', 
                    wingR: wingRPivot, 
                    wingL: wingLPivot, 
                    flapTime: Math.random() * 10 
                };
            }

            scene.add(enemy);
            enemies.push({ mesh: enemy, hit: hitMesh });
        }

        // --- SISTEM KUTIPAN AUTO ---
        function autoAttack() {
            if(!isPlaying) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const targets = enemies.map(e => e.hit);
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                const idx = enemies.findIndex(e => e.hit === target);
                document.getElementById('crosshair').classList.add('locked');

                if (idx > -1) {
                    playChime();
                    for(let i=0; i<15; i++) sparkles.push(new Sparkle(w2D/2, h2D/2));
                    scene.remove(enemies[idx].mesh);
                    enemies.splice(idx, 1);
                    score += 10; document.getElementById('scoreDisplay').innerText = `Cozy: ${score}`;
                }
            } else {
                document.getElementById('crosshair').classList.remove('locked');
            }
        }

        function takeDamage() {
            hp -= 20; document.getElementById('hpBar').style.width = hp + "%";
            // Flash warna cozy gold
            const f = document.getElementById('damageFlash'); f.style.opacity = 0.5; setTimeout(() => f.style.opacity = 0, 100);
            if(hp <= 0) {
                isPlaying = false; clearInterval(enemySpawnInterval);
                document.getElementById('gameUI').style.display = "none";
                document.getElementById('gameOverMenu').style.display = "flex";
                document.getElementById('finalScore').innerText = `Skor Terkumpul: ${score}`;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            let dt = clock.getDelta(); if(dt > 0.1) dt = 0.1;
            let ts = dt * 60;

            if(isPlaying) {
                if (gyroActive && controls) {
                    controls.update();
                    if (!hasCenteredInitially) {
                        centerCamera();
                        hasCenteredInitially = true;
                    }
                } else {
                    camera.rotation.set(rotationX, rotationY, 0);
                }

                autoAttack();

                for(let i = enemies.length-1; i >= 0; i--) {
                    const e = enemies[i];
                    const dir = new THREE.Vector3().subVectors(camera.position, e.mesh.position).normalize();
                    
                    if (e.mesh.userData.type === 'skyStar') {
                        // Pergerakan Shiny Star
                        e.mesh.position.add(dir.multiplyScalar(0.12 * ts));
                        // Bintang berputar secara seragam 
                        e.mesh.userData.starMesh.rotation.y += 0.03 * ts;
                        e.mesh.userData.starMesh.rotation.z += 0.02 * ts;
                        e.mesh.userData.starMesh.rotation.x += 0.01 * ts;
                    } else if (e.mesh.userData.type === 'butterfly') {
                        // Pergerakan Rama-Rama
                        e.mesh.position.add(dir.multiplyScalar(0.08 * ts));
                        e.mesh.lookAt(camera.position); // Muka ke arah pemain
                        
                        // Animasi Mengepak Sayap (Flapping)
                        e.mesh.userData.flapTime += 0.3 * ts;
                        const flapAngle = Math.sin(e.mesh.userData.flapTime) * 0.8; // Kepak naik turun
                        e.mesh.userData.wingR.rotation.z = flapAngle;
                        e.mesh.userData.wingL.rotation.z = -flapAngle;

                        // Rama-rama terapung-apung sikit
                        e.mesh.position.y += Math.sin(Date.now() * 0.003 + e.mesh.userData.flapTime) * 0.015 * ts;
                    }

                    if(e.mesh.position.distanceTo(camera.position) < 2.5) {
                        scene.remove(e.mesh); enemies.splice(i, 1); takeDamage();
                    }
                }

                const rPos = rainGeo.attributes.position.array;
                for(let i=1; i<rPos.length; i+=3) {
                    rPos[i] -= 0.6 * ts; if(rPos[i] < 0) rPos[i] = 40;
                }
                rainGeo.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);

            ctx2D.clearRect(0,0, w2D, h2D);
            for(let i = sparkles.length-1; i >= 0; i--) {
                const s = sparkles[i]; s.update(ts);
                if(s.life <= 0) sparkles.splice(i, 1); else s.draw();
            }
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = "none";
            document.getElementById('gameUI').style.display = "block";
            hasCenteredInitially = false; 
            initAudio();
            if(!scene) init3D();
            score = 0; hp = 100; isPlaying = true;
            clock.start(); animate();
            enemySpawnInterval = setInterval(spawnEnemy, 1600);
        }

        window.addEventListener('resize', () => {
            w2D = window.innerWidth; h2D = window.innerHeight;
            canvas2D.width = w2D; canvas2D.height = h2D;
            camera.aspect = w2D / h2D; camera.updateProjectionMatrix();
            renderer.setSize(w2D, h2D);
        });
    </script>
</body>
</html>


